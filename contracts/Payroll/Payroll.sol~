pragma solidity ^0.4.18;

import "../DateTime/DateTimeInterface.sol";
import "../Token/ERC223ReceivingContract.sol";
import "../Token/EIP20.sol";
import "zeppelin-solidity/contracts/ownership/Ownable.sol";

/// @title Payroll
/// @dev Used to pay employees
contract Payroll is Ownable, ERC223ReceivingContract {
    /*
     * Events
     */
    event EmployeeAdded(uint employeeID);
    event EtherReceived(address from, uint value);
    event TokenReceived(address from, uint value, bytes data);
    event UnsuffisantFund(address tokenAddress);
    event PayementError();

    /*
     * Storage
     */
    uint256 public employeeCount = 0;
    uint256 public nextEmployeeId = 0;
    uint256 internal totalYearlyEURSalary = 0;
    struct Employee {
        address employeeAddress;
        uint256 yearlyEURSalary;
        address[] allowedTokens;
        uint256[] tokenDistribution;
        uint256 lastDistributionUpdate;
        uint256 lastPayDay;
    }
    Employee[] employees;
    mapping(address => uint) public employeesId;
    mapping(address => uint256) public tokenRates;

    /*
     * Public Functions
     */
    /// @dev Payroll(): instantiates the smart contract
    function Payroll() public {}

    /// @dev addEmployee(): instantiates a new employee
    /// @param accountAddress the employee's eth address
    /// @param allowedTokens the list of the authorized tokens
    /// @param initialDistribution the distribution in % of how the employee wants to be paid
    /// @param initialYearlyEURSalary the employee's salary in EUR
    function addEmployee(address accountAddress, address[] allowedTokens, uint256[] initialDistribution, uint256 initialYearlyEURSalary) public onlyOwner {
        require(allowedTokens.length == initialDistribution.length);
        employees[nextEmployeeId] = Employee(accountAddress, initialYearlyEURSalary, allowedTokens, initialDistribution, 0, now);
        employeesId[accountAddress] = nextEmployeeId;
        updateTotalYearlySalary(0, initialYearlyEURSalary);
        EmployeeAdded(nextEmployeeId);
        nextEmployeeId++;
        employeeCount++;
    }

    /// @dev setEmployeeSalary(): Edit the employee salary
    /// @param employeeId the employee's ID
    /// @param yearlyEURSalary the updated employee's salary
    function setEmployeeSalary(uint256 employeeId, uint256 yearlyEURSalary) public onlyOwner {
        updateTotalYearlySalary(employees[employeeId].yearlyEURSalary, yearlyEURSalary);
        employees[employeeId].yearlyEURSalary = yearlyEURSalary;
    }

    /// @dev removeEmployee(): remove an employee form the
    /// @param employeeId the employee's ID
    function removeEmployee(uint256 employeeId) public onlyOwner {
        updateTotalYearlySalary(employees[employeeId].yearlyEURSalary, 0);
        delete employeesId[employees[employeeId].employeeAddress];
        delete employees[employeeId];
        employeeCount--;
    }

    /// Payable
    /// @dev addFunds(): Method to add funds to the smart contract
    function addFunds() public payable {
        EtherReceived(msg.sender, msg.value);
    }

    /// @dev tokenFallback(): Allow the reception of ERC223 tokens
    /// @param from  Token sender address.
    /// @param value Amount of tokens.
    /// @param data  Transaction metadata.
    function tokenFallback(address from, uint value, bytes data) public {
        TokenReceived(from, value, data);
    }

    /// @dev getEmployeeCount(): returns the number of employees
    function getEmployeeCount() constant public returns (uint256) {
        return employeeCount;
    }

    /// @dev getEmployee(): returns important employee's information given an ID
    /// @param employeeId employee's unique ID
    function getEmployee(uint256 employeeId) constant public returns (address employee, uint256 yearlyUSDSalary, uint256 lastDistributionUpdate, uint256 lastPayDay) {
        Employee storage _employee = employees[employeeId];
        return (_employee.employeeAddress, _employee.yearlyEURSalary, _employee.lastDistributionUpdate, _employee.lastPayDay);
    }

    /// @dev calculatePayrollBurnrate(): Monthly EUR amount spent
    function calculatePayrollBurnrate() constant public returns (uint256) {
        return totalYearlyEURSalary / 12;
    }

    /// @dev determineAllocation(): Determines with which tokens the employee wants to be paid
    /// @param tokens is an array of token address
    /// @param distribution array of integer representing the wanted token distribution in %
    /// @notice Can only be called every 6 months
    function determineAllocation(address[] tokens, uint256[] distribution) public {
        Employee storage _employee = employees[employeesId[msg.sender]];
        // Check that the last allocation was more than 6 months ago
        require(now > addMonths(6, _employee.lastDistributionUpdate));
        // Check that the arrays are the same size
        require(tokens.length == distribution.length);
        // Check the total distribution is equal to 100%
        uint total = 0;
        for (uint i = 0; i < distribution.length; i++) {
            total +=  distribution[i];
        }
        require(total == 100);

        uint[] memory newDistribution = new uint[](_employee.allowedTokens.length);
        for (uint j = 0; j < tokens.length; j++) {
            bool result = false;
            for (uint k = 0; k < _employee.allowedTokens.length; k++) {
                if(tokens[j] == _employee.allowedTokens[k]){
                    result = true;
                    newDistribution[k] = distribution[j];
                }
            }
            if(!result){
                revert();
            }
        }
        _employee.tokenDistribution = newDistribution;
        _employee.lastDistributionUpdate = now;
    }

    /// @dev payday(): send employee's salary
    /// @notice can only be called once a month
    function payday() public {
        address employeeAddress = msg.sender;
        Employee storage _employee = employees[employeesId[msg.sender]];

        // check if payday is due
        require(now > addMonths(1, _employee.lastDistributionUpdate));

  	bool enoughFund = true;
        uint[] memory tokenToSend = new uint[](_employee.allowedTokens.length);
        // Check if the contract has suffisant funds
	for (uint i; i < _employee.allowedTokens.length; i++) {
            address tokenAddress = _employee.allowedTokens[i];
                if (_employee.tokenDistribution[i] == 0) {
                    tokenToSend[i] = 0;
  		    continue;
  	         }
  		    else {
  		      uint tokenBalance = EIP20(tokenAddress).balanceOf(this);
      			tokenToSend[i] = (_employee.yearlyEURSalary / 12) / _employee.tokenDistribution[i] / tokenRates[tokenAddress];

      			if (tokenBalance < tokenToSend[i]) {
      		      enoughFund = false;
      			    UnsuffisantFund(tokenAddress);
                revert();
      			}
  		    }
  		}
      // Pay the employee, send the tokens
      for (uint j; j < _employee.allowedTokens.length; j++) {
        if (tokenToSend[j] != 0) {
          if (!EIP20(tokenAddress).transfer(_employee.employeeAddress, tokenToSend[i])) {
            PayementError;
          }
        }
      }
  }

    /*
     * Internal Functions
     */

     /// @dev updateTotalYearlySalary():
     /// @param oldSalary the current salary being updated
     /// @param newSalary the new value
     function updateTotalYearlySalary (uint256 oldSalary, uint newSalary) internal {
         totalYearlyEURSalary -= oldSalary;
         totalYearlyEURSalary += newSalary;
     }

     /// @dev addMonths(): add a unit of month to a timestamp
     /// @param months the number of months to add
     /// @param timestamp the Date and time that needs to be modify
     /// @return the new calculated timestamp
     function addMonths(uint8 months, uint256 timestamp) internal returns (uint256) {
         // Address for the Kovan Testnet
         DateTimeInterface _dateTime = DateTimeInterface(address(0x8Fc065565E3e44aef229F1D06aac009D6A524e82));
         uint16 year = _dateTime.getYear(timestamp);
         uint8 month = _dateTime.getMonth(timestamp);
         // Add the number of months and increment the year if needed
         month += months;
         while(month > 12){
             month -= 12;
             year++;
         }
         // Check the length of the new month
         uint8 lengthMonth = _dateTime.getDaysInMonth(month, year);
         uint8 day = _dateTime.getDay(timestamp);
         if (day > lengthMonth) {
             day = lengthMonth;
         }
         // return the new calculated timestamp
         return _dateTime.toTimestamp(year, month, day, 0, 0, 0);
     }
}
